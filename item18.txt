item18. 최소한 완전한 클래스 인터페이스를 추구한다

클래스의 클라이언트 인터페이스란 함수들만 이러한 인터페이스내에
존자한다. 데이터멤버가 있으면 많은 단점이 있기 때문(항목20)

어떤 함수들이 클래스 인터페이스에 있어야 하는지 구분하는것은 어렵고
완전히 다른 2가지 방향이 존재.
1. 이해하기 쉽고 직관적이며 구현하기 쉬운 클래스
- 적은 갯수의 멤버함수
- 각각의 함수는 명확한 작업 수행.

2. 강력하고 사용하기 편리한 클래스
- 수행하는 작업들을 지원하기 위한 함수들을 추가하는 것.

어떤 함수들이 클래스에 들어가고 들어가지 말아야할지 결정할 것인가?
:최소한의 완전한 클래스 인터페이스를 지향한다.

완전한 인터페이스 => 클라이언트들이 합리적으로 원하는 것들을 수행하게
하는 인터페이스.

※합리적 작업을 위해서는 사용하는 것이 원하는 것만큼 편리하지 않더라도
성취하기 위한 합리적인 방법이 존재.

최소한의 인터페이스 => 내부에 가능한 한 적은 갯수의 함수들을 가진
인터페이스. 기능적으로 함수가 겹치는 경우가 없음.

최소한의, 완전하지않은(나약하게 키우는) 인터페이스를 만드는 이유
=> 꽉찬 인터페이스는 기술적으로 명확한 불이익이 있음.

1. 인터페이스내의 함수들이 많아질수록 미래의 클라이언트들은 이해하기
어려워짐. 또, 커다란 인터페이스는 혼동을 야기함(모두 갈은 같은 일을
함에도 다른 이름으로 불리는 경우)

2. 관리하고 개선하는데 어려움.
- 중복을 피하거나 인터페이스에 대한 일관성 유지가 어려워짐.
- 관련 문서 작성하는 것도 어려워짐.
- 길다란 클래스 정의는 길다란 헤더 파일을 초래(컴파일 시간에도
불이익. 항목34)

※ 인터페이스 함수의 추가는 편리성을 위해서만 추가될 수 있음.
- 함수의 추가는 비용을 초래.
- 편리성이 복잡성, 이해도, 관리 유지 및 컴파일 속도면에서 추가적
부담을 요구하는지 주의깊게 생각해볼 필요 있음.

※ 과도한 절약은 무분별한 것. 가끔 최소한의 함수 이상을 제공하는 것이
정당한 경우도 있음(공통적으로 수행되는 작업을 묶어내는 함수나,
에러방지를 위한 함수등)

//상위 경계와 하위 경계로 배열을 구현한 클래스
template<class T>
class Array {
public:
  enum BoundsCheckingStatus {NO_CHECK_BOUNDS = 0,
    CHECK_BOUNDS = 1};
  
  Array(int lowBounds, int highBounds,
    BoundsChekcingStatus check = NO_CHECK_BOUNDS);

  Array(const Array& rhs);
  ~Array();

  Array& operator=(const Array& rhs);

  private:
  int lBound, hBound; //low bound, high bound

  //배열의 내용. vector정보를 위해선 항목 49 참조
  vector<T> data;

  BoundsCheckingStatus checkingBounds;
};

- 소멸자를 비가상 함수로 선언. 이 클래스는 상위 클래스로 사용되지
  않음(항목 14)
- 치환연산자의 선언이 명확치 않음. Array객체에 대해 치환을 허용하지
  않을수 있음(항목 24참조)
- 유사 배열 vector 템플릿(항목 49)은 치환을 허용.

const와 비const배열 객체를 반환하는 배열 인덱싱 인터페이스 추가.
(반환타입의 차이는 항목 21참조)

//읽고 쓰기 위해 배열 항목을 반환
T& operator [](int index);
//읽기 전용으로 배열 항목을 반환
const T& operator [](int index) const;
  
a의 상위 경계값과 하위 경계값을 반환하는 함수도 추가되어야 함.
치환이 객체의 경계값을 변경할수 있다는 가정 하에 경계값 함수들을
다음처럼 선언(최소한의 인터페이스로)

int lowBound() const;
int highBound() const;

또한 타입T에 대해 cout가 동작하기 위해선, operator<<함수가 타입T의
객체를 위해 정의되어야 함.

항목의 갯수 함수도 추가될수 있음(highBound()-lowBound()+1로 쓸수있긴
하지만, 1을 빼먹을수 있으므로)

입출력을 위한 것들과 다양한 관계 연산자(<,>, ==)가 추가될수
있음. 그러나 operator[] 연산자로 대치될수 있기 때문에, 최소한의
인터페이스는 아님.

프렌드 함수들은 실용적인 목적으로 최소한의 완전한 클래스 인터페이스로
여겨짐.(operator<<, operator>>)
