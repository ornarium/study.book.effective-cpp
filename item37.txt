item37. 계승된 비가상 함수를 재정의하지 않도록 한다.

이론적 관점과 실용적 관점 존재.

<실용적 관점>
* 비가상 함수의 경우 정적으로 결합(항목 38)
class B {
public:
  void mf();
};
class D: public B {
public:
  void mf(); //재정의 했음.
};
D x;
B * pB = &x;
D * pD = &x;
pB->mf(); //pB가 B에 대한 포인터이기에 비가상함수 호출은 B::mf()
pD->mf(); //pD가 D에 대한 포인터이기에 비가상함수 호출은 D::mf()

* 가상 함수의 경우 동적으로 결함(항목 38)

<이론적 관점>
1. public계승이 isa이다(항목 35)
2. 비가상 함수를 선언하는 것이 클래스의 사양이 달라지더라도동일한
기능을 하도록 하기 위한 것(항목 36)

이것을 위의 클래스에 적용하면,
- B객체에 적용한것은 D에도 적용한다(isa)
- B의 하위 클래스들은 mf의 인터페이스와 구현을 함께 계승해야 한다(mf=비가상함수)

즉, D가 mf를 재정의하게 되면 설계에 모순이 생기게 되는 것.
1. D가 B객체이려면, D는 mf를 재정의 해선 안됨.
2. 만약, mf를 재정의 해야 된다면, B::mf는 사양이 달라지더라도 동일해야 하는
내용을 담는 것이 아니다. -> 가상함수이어야 됨.

