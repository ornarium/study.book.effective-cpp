item12. 생성자에서 치환보다는 초기화를 사용한다.

생성자를 작성할때, 인자의 값들을 해당하는 데이터 멤버로 전송하는데
2가지 방법이 있다

1. 멤버 초기화 리스트를 사용하는 것
template<class T>
NamedPtr<T>::NamedPtr(const string& initName, T* initPtr)
: name(initName), ptr(initPtr) {}


초기화 리스트가 반드시 사용되어 지는 부분이 있다. const와 레퍼런스
멤버변수들은 치환될수 없기 때문에 이 때는 초기화 리스트를 사용한다.

2. 생성자의 코드 부분에서 치환 하는 것
template<class T>
NamedPtr<T>::NamedPtr(const string& initNamee, T* initPtr) {
    name = initName;
    ptr = initPtr;
}

생성자 내에서 치환 연산을 하는 것보다 멤버 초기화 리스트를 사용하는
것이 더 효율적이다. 초기화 리스트를 사용하면 해당 string생성자는 한번만
호출 되지만, 2번 방식을 쓰게되면 데이터멤버초기화->호출된생성자코드실행
순으로 진행되기 때문에 실제로는 string 생성자가 두번 호출되게 된다.
(멤버 초기화 리스트에서 없으므로) name에 대한 초기화 인자를 지정하는데
실패하면, 기본 string생성자가 호출되고, 나중에 NamedPtr생성자에서
name에 대한 치환연산을 할때, name에 대해 operator=를 호출하여 총 2번
발생.

※멤버 초기화 리스트를 사용하는 습관을 들이게 되면, const, 레퍼런스의
요구조건과 효율성을 높일수 있다.

※그러나, 객체가 아닌 primitive type의 int, double등은 치환을 쓰는것이
더 효율적이며(생성이 일어나지 않으므로), 코드 작성도 쉽다.

※초기화 루틴은 클래스에 대한 상세 구현을 담기 때문에 private로
선언하는게 좋다

※static 클래스 멤버는 생성자에서 절대 초기화되어서는 안된다. 정적
멤버들은 실행중, 단 한번만 초기화 될 수 있으므로, 객체가 생성될때마다
초기화 된다는것은 말도 안되고 (된다하더라도)비효율적이다. (항목47)
